# -*- coding: utf-8 -*-
"""
KIPRIS ▸ [상세검색] ▸ 인명정보 ▸ 최종권리자(TRH)
고객번호로 검색 → 결과(searchResult.do)에서 '출원번호(일자)'만 수집

설치:
    pip install playwright
    playwright install

실행:
    python kipris_final_owner_appnos.py --customer 120230740981
    # 옵션 없이 실행하면 프롬프트로 고객번호를 받습니다.

옵션:
    --headful         : 브라우저 창 띄워서 실행
    --max-pages N     : 최대 페이지 수 (기본 100)
    --timeout MS      : 단계별 타임아웃(ms, 기본 20000)
"""
import asyncio
import re
import sys
import argparse
from typing import List, Set
from playwright.async_api import async_playwright, Page, TimeoutError as PWTimeoutError

KIPRIS_HOME = "https://www.kipris.or.kr/khome/main.do"
RESULT_URL_RE = re.compile(r"/khome/search/searchResult\.do", re.I)
APPNO_13 = re.compile(r"\b(1|2)\d{12}\b")  # 국내 출원번호(13자리, 10/20 시작)

# ---------------- 유틸 ----------------
async def try_click_many(page: Page, selectors: List[str], timeout: int = 2000) -> bool:
    for sel in selectors:
        try:
            loc = page.locator(sel).first
            if await loc.count():
                try: await loc.scroll_into_view_if_needed()
                except: pass
                try:
                    await loc.click(timeout=timeout)
                    return True
                except:
                    try:
                        ok = await page.evaluate(
                            """(selector) => {
                                const el = document.querySelector(selector);
                                if (!el) return false;
                                el.scrollIntoView({block:'center', inline:'center'});
                                el.click();
                                return true;
                            }""",
                            sel,
                        )
                        if ok: return True
                    except:
                        pass
        except:
            pass
    return False

def prompt_customer() -> str:
    print("\n권리자 고객번호를 입력하세요 (예: 120230740981): ", end="", flush=True)
    try:
        return input().strip()
    except EOFError:
        return ""

# ---------------- 단계 ----------------
async def open_detail_search(page: Page, timeout: int):
    print("[1/6] 메인 접속…", flush=True)
    await page.goto(KIPRIS_HOME, wait_until="domcontentloaded", timeout=timeout)

    # 팝업/배너 닫기
    for sel in ['button:has-text("닫기")', 'button.close', '[aria-label="Close"]']:
        try:
            if await page.locator(sel).count():
                await page.locator(sel).first.click(timeout=800)
        except: pass

    print("[2/6] [상세검색] 진입 시도…", flush=True)
    clicked = await try_click_many(page, [
        "a:has-text('상세검색')", "button:has-text('상세검색')",
        "//a[contains(text(),'상세검색')]", "//button[contains(text(),'상세검색')]",
        "text=상세검색",
    ], timeout=timeout)
    if not clicked:
        print("  - 상세검색 버튼 탐색 실패(상세영역이 기본 노출 레이아웃일 수 있음).", flush=True)

    try:
        await page.wait_for_load_state("networkidle", timeout=timeout)
    except PWTimeoutError:
        pass

async def prepare_TRH_and_input(page: Page, timeout: int):
    print("[3/6] 인명정보 ▸ 최종권리자(TRH) 설정…", flush=True)
    await try_click_many(page, [
        "button:has-text('인명정보')", "a:has-text('인명정보')",
        "//button[contains(text(),'인명정보')]", "//a[contains(text(),'인명정보')]",
    ], timeout=timeout)
    try: await page.wait_for_timeout(300)
    except: pass

    # select#sd01_g04_category_07 => value='TRH', input 후보 반환
    info = await page.evaluate("""
    () => {
      let sel = document.querySelector('#sd01_g04_category_07');
      if (!sel) {
        sel = Array.from(document.querySelectorAll('select')).find(s =>
          Array.from(s.options||[]).some(o => (o.value||'')==='TRH' || /최종권리자/.test(o.textContent||''))
        ) || null;
      }
      if (sel) {
        const prefer = Array.from(sel.options||[]).find(o => (o.value||'')==='TRH');
        if (prefer) sel.value = 'TRH';
        else {
          const byText = Array.from(sel.options||[]).find(o => /최종권리자/.test(o.textContent||''));
          if (byText) sel.value = byText.value;
        }
        sel.dispatchEvent(new Event('input', {bubbles:true}));
        sel.dispatchEvent(new Event('change', {bubbles:true}));
        try { sel.scrollIntoView({block:'center'}); } catch(e) {}
      }

      let inp = document.querySelector('input[data-field="TRH"]');
      if (!inp) inp = document.querySelector('#sd01_g04_text_07');
      if (!inp && sel) {
        const row = sel.closest('.row, tr, .search-row, .cell, .grid, .columns, .f-group') || sel.parentElement;
        if (row) inp = row.querySelector('input[type="text"]');
      }
      if (!inp) {
        inp = Array.from(document.querySelectorAll('input[type="text"]')).find(el => {
          const ph = (el.getAttribute('placeholder')||'') + ' ' + (el.getAttribute('aria-label')||'');
          return /고객번호|특허고객번호|TRH|최종권리자/.test(ph);
        }) || null;
      }
      if (!inp) return { ok:false };

      const selStr = sel ? (sel.id ? '#'+sel.id : 'select') : null;
      const inpStr = inp.id ? ('#'+inp.id) : (inp.getAttribute('data-field') ? `input[data-field="${inp.getAttribute('data-field')}"]` : 'input[type="text"]');
      try { inp.scrollIntoView({block:'center'}); } catch(e) {}
      return { ok:true, inputSelector: inpStr, selectSelector: selStr };
    }
    """)
    if not info or not info.get("ok"):
        raise RuntimeError("TRH 입력칸 탐색 실패")

    return page.locator(info["inputSelector"])

async def submit_search(page: Page, trh_input, customer: str, timeout: int):
    print(f"[4/6] 고객번호 입력: {customer}", flush=True)
    await trh_input.fill(customer, timeout=timeout)
    await page.evaluate("""(sel, val) => {
        const el = document.querySelector(sel);
        if (!el) return;
        el.value = val;
        el.dispatchEvent(new Event('input', {bubbles:true}));
        el.dispatchEvent(new Event('change', {bubbles:true}));
        el.dispatchEvent(new Event('blur', {bubbles:true}));
    }""", await trh_input.evaluate("el => el.id ? '#'+el.id : (el.getAttribute('data-field') ? `input[data-field=\"${el.getAttribute('data-field')}\"]` : 'input[type=\"text\"]')"), customer)

    print("[5/6] 검색 실행…", flush=True)
    clicked = await try_click_many(page, [
        "button:has-text('검색'):not(:has-text('상세'))",
        "button.btn-search", "input[type='submit'][value*='검색']",
        "a:has-text('검색'):not(:has-text('상세'))", "#searchBtn", ".search-btn",
    ], timeout=timeout)

    if not clicked:
        try:
            await page.evaluate("""() => {
                if (window.fnSearchDetail && typeof fnSearchDetail.search === 'function') {
                    fnSearchDetail.search();
                }
            }""")
        except: pass

    # 폼 직접 submit (action*='searchResult.do')
    await page.evaluate("""
    () => {
      const forms = Array.from(document.querySelectorAll('form'));
      const tgt = forms.find(f => (f.getAttribute('action')||'').includes('searchResult.do'));
      if (tgt) { try { tgt.submit(); } catch(e) {} }
    }
    """)
    # 마지막 Enter
    try: await trh_input.press("Enter")
    except: pass

    # 결과 대기
    try:
        await page.wait_for_url(RESULT_URL_RE, timeout=timeout)
    except PWTimeoutError:
        try: await page.wait_for_load_state("networkidle", timeout=timeout)
        except PWTimeoutError: pass

# 🔧 정밀 DOM 선택으로 출원번호만 추출 (괄호 앞 13자리)
async def extract_appnos_on_page(page: Page) -> List[str]:
    # 1) em.tit[data-lang-id="srlt.patent.an"]가 있는 li에서 p.txt 텍스트만 취득
    appnos = await page.evaluate("""
    () => {
      const out = [];
      const labels = document.querySelectorAll('em.tit[data-lang-id="srlt.patent.an"]');
      labels.forEach(em => {
        const li = em.closest('li');
        if (!li) return;
        const p = li.querySelector('div.link-wrap > p.txt');
        if (!p) return;
        const txt = (p.textContent || '').replace(/\\s+/g, '');
        const m = txt.match(/(\\d{13})\\(/); // 괄호 앞 13자리
        if (m) out.push(m[1]);
      });
      return out;
    }
    """)

    # 2) 보조: 타이틀 버튼의 openDetail('kpat','1020160042595',...)에서 추출
    if not appnos or len(appnos) == 0:
        fallback = await page.evaluate("""
        () => {
          return Array.from(document.querySelectorAll('h1.title button[onclick^="openDetail"]'))
            .map(b => (b.getAttribute('onclick')||'').match(/'kpat'\\s*,\\s*'(\\d{13})'/))
            .filter(Boolean).map(m => m[1]);
        }
        """)
        appnos = fallback

    # 정리
    uniq = sorted(set([a for a in appnos if a and (/(1|2)\\d{12}/).test(a)]))
    return uniq

async def paginate(page: Page, timeout: int) -> bool:
    if await try_click_many(page, [
        "a:has-text('다음')", "button:has-text('다음')",
        "a:has-text('Next')", "button:has-text('Next')",
        "a:has-text('＞')", "a:has-text('>')",
        "button:has-text('＞')", "button:has-text('>')",
    ], timeout=timeout):
        try: await page.wait_for_load_state("networkidle", timeout=timeout)
        except PWTimeoutError: pass
        return True
    # 숫자 페이지
    try:
        cur = page.locator('[aria-current="page"]')
        if await cur.count():
            nxt = cur.locator('xpath=following::a[1]')
            if await nxt.count():
                await nxt.first.click(timeout=timeout)
                try: await page.wait_for_load_state("networkidle", timeout=timeout)
                except PWTimeoutError: pass
                return True
    except: pass
    return False

# ---------------- 메인 ----------------
async def _main():
    parser = argparse.ArgumentParser(description="KIPRIS 상세검색 ▸ 인명정보 ▸ 최종권리자(TRH) ▸ '출원번호(일자)' 수집")
    parser.add_argument("--customer", "-c", type=str, default="", help="권리자 고객번호(보통 12자리)")
    parser.add_argument("--headful", action="store_true", help="브라우저 창 표시(디버깅)")
    parser.add_argument("--max-pages", type=int, default=100, help="최대 페이지 수")
    parser.add_argument("--timeout", type=int, default=20000, help="타임아웃(ms)")
    args = parser.parse_args()

    customer = (args.customer or "").strip() or prompt_customer()
    if not customer:
        print("고객번호가 필요합니다.", flush=True); sys.exit(1)
    if customer.isdigit() and len(customer) < 12:
        customer = customer.zfill(12)
    print(f"[고객번호 확인] {customer}", flush=True)

    async with async_playwright() as p:
        browser = await p.chromium.launch(headless=not args.headful)
        page = await browser.new_page()
        try:
            await open_detail_search(page, timeout=args.timeout)
            trh_input = await prepare_TRH_and_input(page, timeout=args.timeout)
            await submit_search(page, trh_input, customer, timeout=args.timeout)

            print("[6/6] 결과 수집…", flush=True)
            all_appnos: Set[str] = set()
            for _ in range(max(1, args.max_pages)):
                for a in await extract_appnos_on_page(page):
                    all_appnos.add(a)
                if not await paginate(page, timeout=args.timeout):
                    break
        finally:
            await browser.close()

    print("\n=== 출원번호(일자) — Application Numbers ===", flush=True)
    lst = sorted(all_appnos)
    print(f"총 {len(lst)}건", flush=True)
    for a in lst:
        print(a, flush=True)

if __name__ == "__main__":
    try:
        asyncio.run(_main())
    except KeyboardInterrupt:
        print("중단됨", flush=True)
